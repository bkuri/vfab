# ploTTY v2 â€” Product Requirements Document (DEFERRED)

**One-liner:** Enhanced ploTTY with TUI interface, multi-device support, and native camera integration while preserving CLI-first architecture.

**Status:** ðŸ“‹ **DEFERRED** - Planned for v2 development after v1 completion

**Targets**
- **Users:** ploTTY v1 users wanting enhanced interactive experience
- **OS:** Linux (primary), macOS, Windows where Textual is supported
- **Interfaces:** CLI + TUI + optional local JSON-RPC
- **Container:** Podman Quadlet (systemd-managed)
- **DB:** SQLite by default; pluggable via SQLAlchemy for Postgres/MySQL later

---

## 1) Goals (v2) / Non-Goals

**Goals** ðŸ“‹ **PLANNED**
- ðŸ“‹ **TUI (Terminal User Interface)** - Interactive terminal interface for ploTTY operations
- ðŸ“‹ **Multi-device support** - Multiple plotter management and orchestration
- ðŸ“‹ **Native camera support** - USB/v4l2 camera integration with custom ffmpeg filters
- ðŸ“‹ **Enhanced performance** - Optimizations for large-scale operations
- ðŸ“‹ **Advanced analytics** - Extended statistics and reporting capabilities

**Non-Goals (v2)**
- GUI or web interface (beyond TUI)
- Cloud accounts/sync, multi-node orchestration
- Non-pen CNC/G-code support

---

## 2) User Stories (v2) ðŸ“‹ **PLANNED**

### 2.1 TUI User Stories

1. ðŸ“‹ **Launch TUI** â†’ User runs `plotty --tui` to enter interactive mode
2. ðŸ“‹ **View Devices** â†’ See connected plotter status and health metrics (multi-device)
3. ðŸ“‹ **Manage Jobs** â†’ Browse, queue, and control plotting jobs interactively
4. ðŸ“‹ **Monitor Progress** â†’ Real-time layer-by-layer progress visualization with ETA and color-coded layer indicators
5. ðŸ“‹ **Control Sessions** â†’ Start, pause, resume, abort plotting sessions
6. ðŸ“‹ **View Guards** â†’ See paper session and pen layer guard status
7. ðŸ“‹ **Device Health** â†’ Monitor plotter health metrics (multi-device)
8. ðŸ“‹ **Job Selection** â†’ Interactive job browsing and selection for plotting

### 2.2 Multi-Device User Stories

9. ðŸ“‹ **Device Discovery** â†’ Automatically detect and configure multiple plotters
10. ðŸ“‹ **Device Pooling** â†’ Create device pools for load balancing
11. ðŸ“‹ **Job Assignment** â†’ Assign jobs to specific devices or device pools
12. ðŸ“‹ **Concurrent Plotting** â†’ Run multiple plotting jobs simultaneously on different devices
13. ðŸ“‹ **Device Monitoring** â†’ Monitor health and status of all connected devices
14. ðŸ“‹ **Failover Handling** â†’ Automatic job reassignment on device failure

### 2.3 Native Camera User Stories

15. ðŸ“‹ **USB Camera Detection** â†’ Automatically detect and configure USB/v4l2 cameras
16. ðŸ“‹ **Custom Filters** â†’ Apply perspective correction, color enhancement, noise reduction
17. ðŸ“‹ **Hardware Acceleration** â†’ Use GPU acceleration for video encoding
18. ðŸ“‹ **Multi-Camera Support** â†’ Support multiple cameras for different viewing angles
19. ðŸ“‹ **Camera Health** â†’ Monitor camera connectivity and feed quality

---

## 3) Architecture (v2) ðŸ“‹ **PLANNED**

```
CLI/TUI â”€â”€> Orchestrator (FSM) â”€â”€> Device Manager (v2: multi-device)
â”‚
â”œâ”€> vpype Runner (subprocess)
â”œâ”€> Estimator (geom + pyaxidraw)
â”œâ”€> Capture (ffmpeg: IP v1 + v4l2 v2)
â”œâ”€> Persistence (SQLite + workspace FS + JSONL journal)
â”œâ”€> Statistics Engine (enhanced)
â””â”€> Device Pool Manager (v2)
```

**TUI Integration:**
- Textual-based interactive interface
- Real-time updates via file system watchers
- State management coordination
- Backward compatibility with CLI

**Multi-Device Architecture:**
- Device discovery and registration
- Pool-based load balancing
- Concurrent job execution
- Device health monitoring

**Native Camera Integration:**
- v4l2 device management
- Custom ffmpeg filter chains
- Hardware-accelerated encoding
- Multi-camera coordination

---

## 4) Data Model Extensions (v2) ðŸ“‹ **PLANNED**

### 4.1 Multi-Device Tables

```sql
-- Device pools for load balancing
device_pools(
    id, name, description, device_ids[], 
    load_balancing_strategy, created_at, updated_at
)

-- Enhanced device tracking
device_status(
    id, device_id, status, health_score, 
    last_heartbeat, current_job_id, error_count
)

-- Job-device assignments
job_assignments(
    id, job_id, device_id, pool_id, 
    assigned_at, started_at, completed_at, status
)
```

### 4.2 Camera Configuration Tables

```sql
-- Camera devices
cameras(
    id, name, device_path, camera_type, 
    resolution, fps, filters_json, created_at
)

-- Camera assignments
camera_assignments(
    id, device_id, camera_id, 
    recording_enabled, settings_json
)
```

---

## 5) TUI Implementation (v2) ðŸ“‹ **PLANNED**

### 5.1 State Management Architecture

**Hybrid State Approach:**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CLI Commands   â”‚â”€â”€â”€â–¶â”‚   JSON Files     â”‚â—€â”€â”€â”€â”‚  File Watchers  â”‚
â”‚  (stateless)    â”‚    â”‚  (persistent)    â”‚    â”‚  (TUI daemon)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â–²                        â”‚
                                 â”‚                        â–¼
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚  Status Commands â”‚    â”‚   TUI Interface â”‚
                        â”‚  (read files)   â”‚    â”‚ (stateful)      â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 TUI Components

**Main Application:**
```python
class PlottyTUI(App):
    """ploTTY Terminal User Interface v2"""
    
    BINDINGS = [
        ("d", "toggle_dark", "Toggle dark mode"),
        ("q", "quit", "Quit"),
        ("p", "plot_job", "Plot Job"), 
        ("s", "stop_plot", "Stop Plot"),
        ("r", "reset_session", "Reset Session"),
        ("c", "check_guards", "Check Guards"),
        ("j", "select_job", "Select Job"),
        ("a", "add_job", "Add Job"),
        ("f5", "refresh", "Refresh"),
        ("1", "switch_device", "Switch Device"),
        ("m", "manage_devices", "Manage Devices")
    ]
```

**Core Widgets:**
- **MultiDeviceWidget:** Device pool status and management
- **JobQueue:** Enhanced DataTable with device assignment
- **LayerProgressBar:** Multi-device progress visualization
- **CameraHealthWidget:** Camera status and monitoring
- **DevicePoolManager:** Pool configuration and load balancing

### 5.3 Layout Structure

```
Header (ploTTY TUI v2)
â”œâ”€ Main Container (Horizontal)
â”‚  â”œâ”€ Sessions Panel (2fr)
â”‚  â”‚  â”œâ”€ Active Sessions Header
â”‚  â”‚  â””â”€ Sessions Scroll (SessionWidgets)
â”‚  â””â”€ Info Panel (1fr)
â”‚     â”œâ”€ Job Queue Widget
â”‚     â”œâ”€ Multi-Device Status Widget
â”‚     â”œâ”€ Camera Health Widget
â”‚     â””â”€ System Health Widget
â””â”€ Footer (keyboard shortcuts)
```

---

## 6) Multi-Device Implementation (v2) ðŸ“‹ **PLANNED**

### 6.1 Device Discovery

```python
class DeviceDiscovery:
    """Automatic device discovery and registration."""
    
    async def discover_axidraw_devices(self) -> List[Device]:
        """Discover AxiDraw devices on USB ports."""
        
    async def discover_v4l2_cameras(self) -> List[Camera]:
        """Discover v4l2 camera devices."""
        
    async def register_device(self, device: Device) -> bool:
        """Register device with the system."""
```

### 6.2 Device Pool Management

```python
class DevicePool:
    """Device pool for load balancing."""
    
    def __init__(self, devices: List[Device], strategy: str = "round_robin"):
        self.devices = devices
        self.strategy = strategy
        self.current_index = 0
    
    def assign_device(self, job: Job) -> Device:
        """Assign device to job based on strategy."""
        
    def release_device(self, device: Device, job: Job):
        """Release device from job assignment."""
```

### 6.3 Concurrent Execution

```python
class ConcurrentOrchestrator:
    """Manage concurrent plotting across multiple devices."""
    
    async def execute_jobs(self, jobs: List[Job]) -> List[JobResult]:
        """Execute jobs concurrently on available devices."""
        
    async def monitor_devices(self) -> Dict[str, DeviceStatus]:
        """Monitor all device health and status."""
```

---

## 7) Native Camera Integration (v2) ðŸ“‹ **PLANNED**

### 7.1 v4l2 Camera Management

```python
class V4L2Camera:
    """v4l2 camera integration."""
    
    def __init__(self, device_path: str, resolution: Tuple[int, int]):
        self.device_path = device_path
        self.resolution = resolution
        self.filters = []
    
    def add_filter(self, filter_chain: str):
        """Add ffmpeg filter chain."""
        
    def start_recording(self, output_path: str) -> subprocess.Popen:
        """Start recording with custom filters."""
```

### 7.2 Custom Filter Chains

**Perspective Correction:**
```bash
ffmpeg -f v4l2 -i /dev/video0 \
       -vf "perspective=x0=100:y0=100:x1=700:y1=100:x2=100:y2=500:x3=700:y3=500" \
       -c:v libx264 -preset ultrafast output.mp4
```

**Color Enhancement:**
```bash
ffmpeg -f v4l2 -i /dev/video0 \
       -vf "eq=contrast=1.2:brightness=0.1:saturation=1.3" \
       -c:v libx264 -preset ultrafast output.mp4
```

**Noise Reduction:**
```bash
ffmpeg -f v4l2 -i /dev/video0 \
       -vf "hqdn3d=4:4:6:6" \
       -c:v libx264 -preset ultrafast output.mp4
```

### 7.3 Hardware Acceleration

```python
class HardwareAcceleratedEncoder:
    """Hardware-accelerated video encoding."""
    
    def get_optimal_encoder(self) -> str:
        """Detect best available hardware encoder."""
        
    def encode_with_gpu(self, input_stream, output_path: str):
        """Encode using GPU acceleration."""
```

---

## 8) Enhanced Statistics (v2) ðŸ“‹ **PLANNED**

### 8.1 Multi-Device Analytics

```python
class MultiDeviceStatistics:
    """Statistics for multi-device operations."""
    
    def get_device_utilization(self, time_range: TimeRange) -> Dict[str, float]:
        """Get utilization metrics per device."""
        
    def get_pool_performance(self, pool_id: str) -> PoolMetrics:
        """Get performance metrics for device pool."""
        
    def get_concurrent_metrics(self) -> ConcurrentMetrics:
        """Get concurrent execution metrics."""
```

### 8.2 Camera Analytics

```python
class CameraAnalytics:
    """Camera performance and usage analytics."""
    
    def get_camera_health(self, camera_id: str) -> CameraHealth:
        """Get camera health and quality metrics."""
        
    def get_recording_stats(self, time_range: TimeRange) -> RecordingStats:
        """Get recording statistics and quality metrics."""
```

---

## 9) Implementation Phases (v2) ðŸ“‹ **PLANNED**

### Phase 1: TUI Foundation (Week 1-2)
1. **Add Textual dependency** to `pyproject.toml`
2. **Create integrated TUI module** at `src/plotty/tui.py`
3. **Add TUI CLI command** with `--tui` flag launch
4. **Basic backend connections** to existing systems
5. **State management system** for CLI/TUI coordination

### Phase 2: Multi-Device Support (Week 3-4)
6. **Device discovery system** for automatic detection
7. **Device pool management** with load balancing
8. **Concurrent execution engine** for multi-device plotting
9. **Enhanced device monitoring** and health tracking
10. **Multi-device CLI commands** and management

### Phase 3: Native Camera Integration (Week 5-6)
11. **v4l2 camera management** system
12. **Custom ffmpeg filter chains** for enhancement
13. **Hardware-accelerated encoding** support
14. **Multi-camera coordination** and management
15. **Camera health monitoring** and analytics

### Phase 4: Enhanced Analytics (Week 7-8)
16. **Multi-device statistics** and reporting
17. **Camera analytics** and quality metrics
18. **Performance optimization** for large-scale operations
19. **Advanced reporting** and visualization
20. **Integration testing** and documentation

---

## 10) Success Criteria (v2) ðŸ“‹ **PLANNED**

### 10.1 Functional Requirements

**TUI Features:**
- [ ] TUI launches with `plotty --tui`
- [ ] Real-time multi-device status monitoring
- [ ] Interactive job queue management
- [ ] Device pool visualization and control
- [ ] Camera health monitoring integration

**Multi-Device Features:**
- [ ] Automatic device discovery and registration
- [ ] Device pool creation and management
- [ ] Concurrent plotting on multiple devices
- [ ] Load balancing across device pools
- [ ] Failover handling and recovery

**Camera Features:**
- [ ] USB/v4l2 camera detection and configuration
- [ ] Custom filter chain application
- [ ] Hardware-accelerated video encoding
- [ ] Multi-camera support and coordination
- [ ] Camera health monitoring and analytics

### 10.2 Performance Requirements

**TUI Performance:**
- [ ] UI refresh rate â‰¥ 10Hz for smooth updates
- [ ] Real-time updates latency < 100ms
- [ ] Memory usage for TUI < 100MB
- [ ] Responsive keyboard controls

**Multi-Device Performance:**
- [ ] Concurrent job execution without interference
- [ ] Device utilization > 80% for pooled operations
- [ ] Load balancing overhead < 5%
- [ ] Failover recovery time < 30 seconds

**Camera Performance:**
- [ ] Real-time video encoding at 1080p30
- [ ] Hardware acceleration utilization when available
- [ ] Filter processing overhead < 10%
- [ ] Camera health monitoring interval < 5 seconds

---

## 11) Migration Strategy (v2) ðŸ“‹ **PLANNED**

### 11.1 Backward Compatibility

**CLI Compatibility:**
- All existing CLI commands continue to work unchanged
- File-based state remains primary storage
- Existing workflows preserved without modification

**Database Migration:**
- Alembic migrations for new tables and indexes
- Data migration scripts for existing installations
- Rollback procedures for v2 â†’ v1 downgrade

**Configuration Migration:**
- Automatic configuration file updates
- Legacy configuration support
- Migration wizard for complex setups

### 11.2 Gradual Transition

**Phase 1: Foundation**
- Add TUI as optional interface
- Maintain CLI as primary interface
- Introduce state management system

**Phase 2: Enhancement**
- Multi-device support alongside single-device
- Native camera alongside IP camera
- Enhanced statistics with backward compatibility

**Phase 3: Integration**
- Full TUI feature parity with CLI
- Seamless multi-device operation
- Complete camera integration

---

## 12) Dependencies (v2) ðŸ“‹ **PLANNED**

### 12.1 New Dependencies

```toml
[project.optional-dependencies]
tui = ["textual>=0.44.0"]
multidevice = ["pyserial>=3.5"]
camera = ["opencv-python>=4.8", "v4l2-python>=0.3"]
performance = ["numpy>=1.24", "scipy>=1.10"]
```

### 12.2 System Dependencies

```bash
# Ubuntu/Debian
sudo apt-get install v4l-utils libopencv-dev python3-opencv

# Arch Linux
sudo pacman -S v4l-utils opencv python-opencv

# Fedora
sudo dnf install v4l-utils opencv-devel python3-opencv
```

---

## 13) Risk Mitigation (v2) ðŸ“‹ **PLANNED**

### 13.1 Technical Risks

**TUI Complexity:**
- **Risk:** State synchronization between CLI and TUI
- **Mitigation:** File-based state with atomic operations, comprehensive testing

**Multi-Device Coordination:**
- **Risk:** Resource conflicts and device contention
- **Mitigation:** Device locking, resource scheduling, comprehensive monitoring

**Camera Integration:**
- **Risk:** Hardware compatibility issues across platforms
- **Mitigation:** Extensive hardware testing, fallback mechanisms, clear documentation

### 13.2 Performance Risks

**TUI Responsiveness:**
- **Risk:** UI lag during heavy operations
- **Mitigation:** Background processing, efficient updates, progress indicators

**Concurrent Execution:**
- **Risk:** Performance degradation with multiple devices
- **Mitigation:** Resource isolation, load balancing, performance monitoring

**Video Processing:**
- **Risk:** High CPU usage for video encoding
- **Mitigation:** Hardware acceleration, optimized codecs, quality settings

---

## 14) v2 Development Status ðŸ“‹ **PLANNED**

**Current Status:** Planning phase - v1 complete, v2 design finalized
**Target Start:** Q1 2026 (after v1 stabilization)
**Estimated Duration:** 8 weeks
**Priority:** Medium (v1 production stability takes precedence)

### 14.1 Prerequisites

- [ ] v1 production stability confirmed
- [ ] User feedback collected from v1 deployment
- [ ] Performance benchmarks established
- [ ] Hardware compatibility testing completed

### 14.2 Development Resources

- **Frontend Developer:** TUI implementation (Textual)
- **Backend Developer:** Multi-device orchestration
- **Systems Engineer:** Camera integration and performance
- **QA Engineer:** Integration testing and validation

---

## 15) Next Steps ðŸ“‹ **PLANNED**

1. **Finalize v2 requirements** based on v1 user feedback
2. **Set up development environment** with multi-device hardware
3. **Create detailed implementation timeline** with milestones
4. **Begin Phase 1: TUI Foundation** development
5. **Establish testing framework** for multi-device scenarios
6. **Document migration procedures** for existing users

---

**v2 represents the next evolution of ploTTY**, adding interactive TUI capabilities, multi-device support, and native camera integration while maintaining the robust CLI-first architecture established in v1. Development will proceed after v1 achieves production stability and user feedback is incorporated.